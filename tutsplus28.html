
<!DOCTYPE html>
<html>
 <head> 
  <title>Normal maps</title> 
  <script type="text/javascript" src="js/r69/three.min.js"></script>
  <script src="js/OrbitControls.js"></script>  
  <script type="text/javascript" src="js/dat.gui.min.js"></script> 
<style>
	body {
		background-color: #fff;
		color: #111;
		margin: 0px;
		overflow: hidden;
		font-family: Monospace;
		font-size: 20px;
		position: absolute;
	}
	#info {
		position: absolute;
		top: 0px; width: 100%;
		
		padding: 5px;
		text-align: center;
		color: #008888
	}
	a {color: #00ffff}
	strong {color:red}
</style>
 </head> 

 <body> 
  <!-- Div which will hold the Output --> 
<div id="info">
    webgl tutorial 28 <br/><br/>
	Normal Map <br/>
</div>
  <div id="WebGL-output"> 
  </div> 

  <!-- Javascript code that runs our Three.js examples --> 

  <script type="text/javascript">

// once everything is loaded, we run our Three.js stuff.
var scene, camera, webGLRenderer;
var step;
var sphereLightMesh;
var directionalLight;
var controls;

init();
render();

function init() 
{
    // create a scene, that will hold all our elements such as objects, cameras and lights.
    scene = new THREE.Scene();

    // create a camera, which defines where we're looking at.
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

    // create a render and set the size
    webGLRenderer = new THREE.WebGLRenderer();
    webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
    webGLRenderer.setSize(window.innerWidth, window.innerHeight);
    webGLRenderer.shadowMapEnabled = true;

	controls = new THREE.OrbitControls (camera, webGLRenderer.domElement);
	
    var sphere1 = createMesh(new THREE.BoxGeometry(15, 15, 15), "images/plaster.jpg");
    sphere1.rotation.y = -0.5;
    sphere1.position.x = 12;
    scene.add(sphere1);

    var sphere2 = createMesh(new THREE.BoxGeometry(15, 15, 15), "images/plaster.jpg", "images/plaster-normal.jpg");
    sphere2.rotation.y = 0.5;
    sphere2.position.x = -12;
    scene.add(sphere2);
	
    console.log(sphere2.geometry.faceVertexUvs);

    var floorTex = THREE.ImageUtils.loadTexture("images/floor-wood.jpg")
    var plane = new THREE.Mesh(new THREE.BoxGeometry(200, 100, 0.1, 30), new THREE.MeshPhongMaterial({color: 0x3c3c3c, map: floorTex}));
    plane.position.y = -7.5;
    plane.rotation.x = -0.5 * Math.PI;
    scene.add(plane);

    // position and point the camera to the center of the scene
    camera.position.x = 00;
    camera.position.y = 12;
    camera.position.z = 38;
    camera.lookAt(new THREE.Vector3(0, 0, 0));

    var ambiLight = new THREE.AmbientLight(0x242424)
    scene.add(ambiLight);

    var light = new THREE.SpotLight();
    light.position.set(0, 30, 30);
    light.intensity = 1.2;
    scene.add(light);

//        var pointColor = "#ff5808";
    var pointColor = "#ff5808";
    directionalLight = new THREE.PointLight(pointColor);


//        directionalLight.distance = 0;
//        directionalLight.intensity = 0.5;


    scene.add(directionalLight);


    // add a small sphere simulating the pointlight
    var sphereLight = new THREE.SphereGeometry(0.2);
    var sphereLightMaterial = new THREE.MeshBasicMaterial({color: 0xac6c25});
    sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial);
    sphereLightMesh.castShadow = true;

    sphereLightMesh.position = new THREE.Vector3(3, 3, 3);
    scene.add(sphereLightMesh);

    // add the output of the renderer to the html element
	document.body.appendChild (webGLRenderer.domElement); 

    // call the render function
    step = 0;

//        var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices, faces, controls.radius, controls.detail));
/*
    // setup the control gui
    var controls = new function () {
        this.normalScale = 1;
        this.changeTexture = "plaster";
        this.rotate = false;

        this.changeTexture = function (e) {
            var texture = THREE.ImageUtils.loadTexture("../assets/textures/general/" + e + ".jpg");
            sphere2.material.map = texture;
            sphere1.material.map = texture;

            var bump = THREE.ImageUtils.loadTexture("../assets/textures/general/" + e + "-normal.jpg");
            sphere2.material.normalMap = bump;
        }

        this.updateBump = function (e) {
            sphere2.material.normalScale.set(e, e);
        }
    };


    var gui = new dat.GUI();
    gui.add(controls, "normalScale", -2, 2).onChange(controls.updateBump);
    gui.add(controls, "changeTexture", ['plaster', 'bathroom', 'metal-floor']).onChange(controls.changeTexture);
    gui.add(controls, "rotate");
*/
	window.addEventListener ('resize', onWindowResize, false);	
}
function onWindowResize()
{
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	webGLRenderer.setSize (window.innerWidth, window.innerHeight);
}

function createMesh(geom, imageFile, normal) {

	if (normal) {
		var t = THREE.ImageUtils.loadTexture(imageFile);
		var m = THREE.ImageUtils.loadTexture(normal);
		var mat2 = new THREE.MeshPhongMaterial({
			map: t,
			normalMap: m
		});
		var mesh = new THREE.Mesh(geom, mat2);
		return mesh;
	} else {
		var t = THREE.ImageUtils.loadTexture(imageFile);
		var mat1 = new THREE.MeshPhongMaterial({
			map: t
		})
		var mesh = new THREE.Mesh(geom, mat1);
		return mesh;
	}

	return mesh;
}

function createNormalmapShaderMaterial(diffuseMap, normalMap) {
	var shader = THREE.ShaderLib[ "normalmap" ];
	var uniforms = THREE.UniformsUtils.clone(shader.uniforms);

	var dT = THREE.ImageUtils.loadTexture(diffuseMap);
	var nT = THREE.ImageUtils.loadTexture(normalMap);

	uniforms["uShininess"].value = 50;
	uniforms["enableDiffuse"].value = true;
	uniforms["uDiffuseColor"].value.setHex(0xffffff);
	uniforms["tDiffuse"].value = dT;
	uniforms["tNormal"].value = nT;

	uniforms["uNormalScale" ].value.set(1, 1);
	uniforms["uSpecularColor"].value.setHex(0xffffff);
	uniforms["enableSpecular"].value = true;

	return new THREE.ShaderMaterial(
			{
				fragmentShader: shader.fragmentShader,
				vertexShader: shader.vertexShader,
				uniforms: uniforms,
				lights: true
			});
}

var invert = 1;
var phase = 0;

function render() {
	controls.update();
	
	//stats.update();
	step += 0.1;
/*
	if (controls.rotate) {
		sphere1.rotation.y -= 0.01;
		sphere2.rotation.y += 0.01;
	}
*/

	if (phase > 2 * Math.PI) {
		invert = invert * -1;
		phase -= 2 * Math.PI;
	} else {
		phase += 0.03;
	}

	sphereLightMesh.position.z = +(21 * (Math.sin(phase)));
	sphereLightMesh.position.x = -14 + (14 * (Math.cos(phase)));

	if (invert < 0) {
		var pivot = 0;
		sphereLightMesh.position.x = (invert * (sphereLightMesh.position.x - pivot)) + pivot;
	}

//	directionalLight.position = sphereLightMesh.position;
	directionalLight.position.copy ( sphereLightMesh.position );


//            sphere1.rotation.y=step+=0.01;
//            sphere1.rotation.x=step;
//            sphere2.rotation.y=step;
//            sphere2.rotation.x=step;

	// render using requestAnimationFrame
	requestAnimationFrame(render);
	webGLRenderer.render(scene, camera);
}




</script>  
 </body>
</html>