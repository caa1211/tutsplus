
<!DOCTYPE html>
<html>
 <head> 
  <title>Bump maps</title> 
  <script type="text/javascript" src="js/r69/three.min.js"></script> 
  <script src="js/OrbitControls.js"></script>
  <script type="text/javascript" src="js/dat.gui.min.js"></script> 
<style>
	body {
		background-color: #fff;
		color: #111;
		margin: 0px;
		overflow: hidden;
		font-family: Monospace;
		font-size: 20px;
		position: absolute;
	}
	#info {
		position: absolute;
		top: 0px; width: 100%;
		
		padding: 5px;
		text-align: center;
		color: #008888
	}
	a {color: #888800}
	strong {color:red}
</style>

</head> 
 <body> 
 <div id="info">
    webgl tutorial 29 <br/><br/>
	Bump Map <br/>
	<a href="http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html">
	(Derivative Map)</a>
</div>

  <!-- Div which will hold the Output --> 
  <div id="WebGL-output"> 
  </div> 
  <!-- Javascript code that runs our Three.js examples --> 
  <script type="text/javascript">

var scene, camera, webGLRenderer, step;
var controls;

init();
render();

function init() 
{
        // create a scene, that will hold all our elements such as objects, cameras and lights.
        scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

        // create a render and set the size
        webGLRenderer = new THREE.WebGLRenderer();
        webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
        webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        webGLRenderer.shadowMapEnabled = true;

		controls = new THREE.OrbitControls (camera, webGLRenderer.domElement);
		
        var sphere1 = createMesh(new THREE.BoxGeometry(15, 15, 2), "stone.jpg");
        sphere1.rotation.y = -0.75;
        sphere1.position.x = 12;
        scene.add(sphere1);

        var sphere2 = createMesh(new THREE.BoxGeometry(15, 15, 2), "stone.jpg", "stone-bump.jpg");
        sphere2.rotation.y = 0.75;
        sphere2.position.x = -12;
        scene.add(sphere2);
        console.log(sphere2.geometry.faceVertexUvs);

        var floorTex = THREE.ImageUtils.loadTexture("images/floor-wood.jpg")
        var plane = new THREE.Mesh(new THREE.BoxGeometry(200, 100, 0.1, 30), new THREE.MeshPhongMaterial({color: 0x3c3c3c, map: floorTex}));
        plane.position.y = -7.5;
        plane.rotation.x = -0.5 * Math.PI;
        scene.add(plane);

        // position and point the camera to the center of the scene
        camera.position.x = 00;
        camera.position.y = 12;
        camera.position.z = 28;
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        var ambiLight = new THREE.AmbientLight(0x242424)
        scene.add(ambiLight);

        var light = new THREE.SpotLight();
        light.position.set(0, 30, 30);
        light.intensity = 1.2;
        scene.add(light);

		document.body.appendChild (webGLRenderer.domElement);

        // call the render function
        step = 0;

//        var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices, faces, controls.radius, controls.detail));

/*
        // setup the control gui
        var controls = new function () {
            this.bumpScale = 0.2;
            this.changeTexture = "weave";
            this.rotate = false;

            this.changeTexture = function (e) {
                var texture = THREE.ImageUtils.loadTexture("../assets/textures/general/" + e + ".jpg");
                sphere2.material.map = texture;
                sphere1.material.map = texture;

                var bump = THREE.ImageUtils.loadTexture("../assets/textures/general/" + e + "-bump.jpg");
                sphere2.material.bumpMap = bump;
            }

            this.updateBump = function (e) {
                console.log(sphere2.material.bumpScale);
                sphere2.material.bumpScale = e;
            }
        };


        var gui = new dat.GUI();
        gui.add(controls, "bumpScale", -2, 2).onChange(controls.updateBump);
        gui.add(controls, "changeTexture", ['stone', 'weave']).onChange(controls.changeTexture);
        gui.add(controls, "rotate");
*/
	window.addEventListener ('resize', onWindowResize, false);	
}
function onWindowResize()
{
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	webGLRenderer.setSize (window.innerWidth, window.innerHeight);
}

        function createMesh(geom, imageFile, bump) {
            var texture = THREE.ImageUtils.loadTexture("images/" + imageFile)
            geom.computeVertexNormals();
            var mat = new THREE.MeshPhongMaterial();
            mat.map = texture;

            if (bump) {
                var bump = THREE.ImageUtils.loadTexture("images/" + bump)
                mat.bumpMap = bump;
                mat.bumpScale = 0.2;
                console.log('d');
            }


            // create a multimaterial
            var mesh = new THREE.Mesh(geom, mat);

            return mesh;
        }

        function render() {
			controls.update();
/*
            if (controls.rotate) {
                sphere1.rotation.y -= 0.01;
                sphere2.rotation.y += 0.01;
            }
*/
//            sphere1.rotation.y=step+=0.01;
//            sphere1.rotation.x=step;
//            sphere2.rotation.y=step;
//            sphere2.rotation.x=step;

            // render using requestAnimationFrame
            requestAnimationFrame(render);
            webGLRenderer.render(scene, camera);
        }


</script>  
 </body>
</html>